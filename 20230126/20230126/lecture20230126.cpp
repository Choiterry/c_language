// 2의 보수 찾기는 원래 이진수의 전환 +1 로 구한다.
// char c = -1 는 c = 1000 0001 이므로 255를 뜻한다
//unsigned char c = 255 는 c = 1111 1111 이고 1 = 0000 0001의 보수는 1111 1110 + 1 == 1111 1111이므로 -1로 저장된다.

//실수 % 실수 = 오류가 뜬다. //실수는 나머지가 있을 수 없다. 연산자 피연산자 모두 정수 일때만 %가 쓸수 있다.
//double float은 실수 변수형 0.23f 12.25d 등으로 표시
// !true 는 false로 본다 보통은 0은 false 1은 true
//삼항연산자 itest ==10? itest =1 : itest=2 ; 이런 방법도 있다
//비트연산자 10<<2 는 1010(2)를 왼쪽 으로 두칸 옮긴 것이므로 10100(2) = 32+8 = 40 이므로 10 곱하기 4이다.
//비트연산자
// & 둘다 1이면 1(곱) 
//| 둘중 하나만 1이어도 1(합)
// ^ 같으면 0 다르면 1
//~ 1을 0으로 전환 0을 1로 전환
//#include<stdio.h> 일때 prtintf scanf 사용할 수 있는데 printf("123 %d fgas",10); 이면 %d 에 정수10이 나온다
//#include<stdio.h> 일때 prtintf scanf 사용할 수 있는데 printf("123 %f fgas",1.00); 이면 %f 에 실수1.00이 나온다
//재귀함수 잘 쓰면 존나 효율적으로 쓸수 있고 계층구조의 데이터들을 사용하기 좋다 - 피보나치수열, 팩토리알
//재귀함수는 함수안에 본인함수를 재호출하기
